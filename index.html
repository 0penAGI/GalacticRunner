<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic X-Dust Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0ff;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        #feedback-canvas {
            mix-blend-mode: screen;
            opacity: 0.7;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
        }
        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 16px;
        }
        #xdust {
            color: #f0f;
            font-size: 20px;
            font-weight: bold;
        }
        #level { color: #ff0; }
        #aliens { color: #0f0; }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-shadow: 0 0 20px #0ff;
            z-index: 20;
        }
        .show { opacity: 1 !important; }
        #user-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="feedback-canvas"></canvas>
    <canvas id="canvas"></canvas>
    <div id="hud">
        <div class="hud-row">
            <div id="xdust">$XDUST: 0</div>
            <div id="level">SECTOR: 1</div>
        </div>
        <div class="hud-row">
            <div id="aliens">üëΩ: 0</div>
            <div>SPEED: <span id="speed">1.0</span>x</div>
        </div>
    </div>
    <div id="message"></div>
    <div id="user-info"></div>

<script>
    // AUDIO ENGINE - –∂–∏–≤–æ–π –∑–≤—É–∫ –∫–æ—Å–º–æ—Å–∞
    let audioInitialized = false;
    let ambientSynth, dustSynth, alienSynth, obstacleSynth, feedbackDelay, reverb, filter;

    async function initAudio() {
        if (audioInitialized) return;
        audioInitialized = true;
        await Tone.start();

        reverb = new Tone.Reverb({decay: 8, wet: 0.4}).toDestination();
        feedbackDelay = new Tone.FeedbackDelay("8n", 0.6).connect(reverb);
        filter = new Tone.AutoFilter("0.5hz").connect(feedbackDelay).start();

        // ambient drone - –∫–æ—Å–º–∏—á–µ—Å–∫–æ–µ –¥—ã—Ö–∞–Ω–∏–µ
        ambientSynth = new Tone.PolySynth(Tone.AMSynth, {
            harmonicity: 3.5,
            modulationIndex: 12,
            envelope: {attack: 2, decay: 1, sustain: 0.8, release: 3}
        }).connect(filter);

        // dust sparkle - –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
        dustSynth = new Tone.MetalSynth({
            frequency: 800,
            envelope: {attack: 0.001, decay: 0.2, release: 0.3},
            harmonicity: 12,
            modulationIndex: 40,
            resonance: 3000,
            octaves: 1.5
        }).connect(reverb);

        // alien encounter - –∫–æ–Ω—Ç–∞–∫—Ç
        alienSynth = new Tone.DuoSynth({
            voice0: {oscillator: {type: "sawtooth"}, envelope: {attack: 0.05, decay: 0.2}},
            voice1: {oscillator: {type: "sine"}, envelope: {attack: 0.05, decay: 0.2}},
            vibratoRate: 5,
            vibratoAmount: 0.5
        }).connect(feedbackDelay);

        // obstacle danger - –∏—Å–∫–∞–∂–µ–Ω–∏–µ
        obstacleSynth = new Tone.NoiseSynth({
            noise: {type: "pink"},
            envelope: {attack: 0.005, decay: 0.1, sustain: 0}
        }).connect(reverb);

        // –∂–∏–≤–æ–µ –¥—ã—Ö–∞–Ω–∏–µ –∫–æ—Å–º–æ—Å–∞
        function breathe() {
            const notes = ["C2", "G2", "C3", "E3"];
            const note = notes[Math.floor(Math.random() * notes.length)];
            ambientSynth.triggerAttackRelease(note, "4n", undefined, 0.05 + Math.random() * 0.1);
            setTimeout(breathe, 3000 + Math.random() * 5000);
        }
        breathe();
    }

    function playDust() {
        if (!audioInitialized) return;
        const freq = 600 + Math.random() * 800;
        dustSynth.frequency.value = freq;
        dustSynth.triggerAttackRelease("32n");
    }

    function playAlien() {
        if (!audioInitialized) return;
        const notes = ["E4", "G4", "B4", "D5"];
        alienSynth.triggerAttackRelease(notes, "8n");
    }

    function playObstacle() {
        if (!audioInitialized) return;
        obstacleSynth.triggerAttackRelease("16n");
    }

    // TELEGRAM
    const tg = window.Telegram?.WebApp;
    if (tg) {
        tg.ready();
        tg.expand();
        const user = tg.initDataUnsafe?.user;
        if (user) {
            document.getElementById('user-info').textContent = 
                `Player: ${user.first_name || 'Unknown'} (ID: ${user.id})`;
        }
    }

    // FEEDBACK CANVAS - —Ç–µ–∫—É—á–∏–π —Å–ª–µ–¥
    const fbCanvas = document.getElementById('feedback-canvas');
    const fbCtx = fbCanvas.getContext('2d', {alpha: true});
    fbCanvas.width = window.innerWidth;
    fbCanvas.height = window.innerHeight;

    // MAIN CANVAS
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) alert('WebGL2 not supported');

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
        width = canvas.width = fbCanvas.width = window.innerWidth;
        height = canvas.height = fbCanvas.height = window.innerHeight;
        gl.viewport(0, 0, width, height);
    });

    // SHADERS
    const vertexShaderSource = `#version 300 es
        in vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;

    const fragmentShaderSource = `#version 300 es
        precision highp float;
        
        uniform vec2 resolution;
        uniform float time;
        uniform vec2 ship;
        uniform float speed;
        uniform float sectorPhase;
        uniform vec3 entities[100];
        uniform int entityCount;
        uniform float audioEnergy;
        
        out vec4 fragColor;
        
        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        vec3 palette(float t, float phase) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.0 + phase, 0.33, 0.67 - phase);
            return a + b * cos(6.28318 * (c * t + d));
        }
        
        float circle(vec2 uv, vec2 pos, float radius) {
            return 1.0 - smoothstep(radius - 2.0, radius + 2.0, length(uv - pos));
        }
        
        float shipGlow(vec2 uv, vec2 pos) {
            float dist = length(uv - pos);
            return 0.8 * exp(-dist * 0.05) + 0.2 * exp(-dist * 0.01);
        }
        
        void main() {
            vec2 uv = gl_FragCoord.xy;
            vec2 shipPos = ship;
            
            vec2 scrollUv = uv / resolution;
            scrollUv.y += time * speed * 0.3;
            
            // displacement –æ—Ç –∑–≤—É–∫–∞
            float disp = audioEnergy * 0.02;
            scrollUv.x += sin(scrollUv.y * 10.0 + time) * disp;
            scrollUv.y += cos(scrollUv.x * 10.0 + time) * disp;
            
            float dust = 0.0;
            for(int i = 0; i < 4; i++) {
                float layer = float(i) + 1.0;
                vec2 p = scrollUv * layer * 3.0;
                p.y += time * speed * layer * 0.5;
                float n = noise(p);
                n = smoothstep(0.45, 0.55, n);
                dust += n * (1.0 / layer);
            }
            
            vec2 toShip = scrollUv - shipPos / resolution;
            float distToShip = length(toShip);
            float tunnel = 1.0 - exp(-distToShip * 2.0);
            
            vec2 nebulaUv = scrollUv * 2.0;
            nebulaUv.y += time * speed * 0.1;
            float nebula = 0.0;
            for(int i = 0; i < 3; i++) {
                nebula += noise(nebulaUv * float(i + 1) * 0.5) / float(i + 2);
            }
            
            float pattern = dust * 0.7 + nebula * 0.3;
            pattern *= tunnel;
            pattern += audioEnergy * 0.1;
            
            vec3 col = palette(pattern + time * 0.1, sectorPhase);
            
            float stars = 0.0;
            vec2 starUv = floor(scrollUv * 100.0);
            if(hash(starUv) > 0.97) {
                float twinkle = 0.5 + 0.5 * sin(time * 3.0 + hash(starUv) * 100.0);
                stars = twinkle;
            }
            col += vec3(stars) * 0.8;
            
            float vignette = 1.0 - distToShip * 0.3;
            col *= vignette;
            
            for(int i = 0; i < entityCount && i < 100; i++) {
                vec3 entity = entities[i];
                vec2 entityPos = entity.xy;
                float entityType = entity.z;
                float c = circle(uv, entityPos, 20.0);
                
                if(c > 0.0) {
                    if(entityType < 0.5) {
                        vec3 dustCol = vec3(1.0, 1.0, 0.5);
                        float sparkle = 0.5 + 0.5 * sin(time * 10.0 + float(i));
                        col = mix(col, dustCol, c * sparkle);
                    } else if(entityType < 1.5) {
                        vec3 alienCol = vec3(0.0, 1.0, 0.5);
                        float pulse = 0.7 + 0.3 * sin(time * 5.0 + float(i));
                        col = mix(col, alienCol, c * pulse);
                    } else {
                        vec3 obstacleCol = vec3(1.0, 0.2, 0.0);
                        float danger = 0.6 + 0.4 * sin(time * 8.0);
                        col = mix(col, obstacleCol, c * danger);
                    }
                }
            }
            
            float shipEffect = shipGlow(uv, shipPos);
            vec3 shipCol = vec3(0.0, 1.0, 1.0);
            float shipCore = circle(uv, shipPos, 15.0);
            col = mix(col, shipCol, shipCore);
            col += shipCol * shipEffect * 0.3;
            
            vec2 trailDir = vec2(0.0, 1.0);
            for(int i = 0; i < 5; i++) {
                float offset = float(i) * 10.0;
                vec2 trailPos = shipPos + trailDir * offset;
                float trailCircle = circle(uv, trailPos, 8.0 - float(i) * 1.5);
                float fade = 1.0 - float(i) / 5.0;
                col += shipCol * trailCircle * fade * 0.5;
            }
            
            fragColor = vec4(col, 1.0);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    const resolutionLoc = gl.getUniformLocation(program, 'resolution');
    const timeLoc = gl.getUniformLocation(program, 'time');
    const shipLoc = gl.getUniformLocation(program, 'ship');
    const speedLoc = gl.getUniformLocation(program, 'speed');
    const sectorPhaseLoc = gl.getUniformLocation(program, 'sectorPhase');
    const entitiesLoc = gl.getUniformLocation(program, 'entities');
    const entityCountLoc = gl.getUniformLocation(program, 'entityCount');
    const audioEnergyLoc = gl.getUniformLocation(program, 'audioEnergy');

    // GAME STATE
    let shipX = width / 2;
    let shipY = height * 0.75;
    let xdust = 0;
    let aliens = 0;
    let sector = 1;
    let speed = 1.0;
    let sectorPhase = 0;
    let audioEnergy = 0;

    const entities = [];
    const shipTrail = [];
    
    class Entity {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.typeNum = type === 'dust' ? 0 : type === 'alien' ? 1 : 2;
            this.collected = false;
        }
        
        update(dt) {
            this.y += speed * 300 * dt;
        }
        
        checkCollision(sx, sy) {
            const dx = this.x - sx;
            const dy = this.y - sy;
            return Math.sqrt(dx * dx + dy * dy) < 35;
        }
    }

    function spawnEntity() {
        const x = Math.random() * width;
        const y = -50;
        const rand = Math.random();
        let type = rand < 0.3 ? 'alien' : rand < 0.65 ? 'dust' : 'obstacle';
        entities.push(new Entity(x, y, type));
    }

    function showMessage(text, duration = 1000) {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), duration);
    }

    let spawnTimer = 0;
    const spawnInterval = 0.7;
    let targetX = shipX;
    let targetY = shipY;

    function handleMove(x, y) {
        targetX = x;
        targetY = y;
    }

    canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleMove(e.touches[0].clientX, e.touches[0].clientY);
    });
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleMove(e.touches[0].clientX, e.touches[0].clientY);
        initAudio();
    });
    canvas.addEventListener('click', initAudio);

    let lastTime = 0;

    // FEEDBACK RENDER - —Ç–µ–∫—É—á–∏–π –∂–∏–≤–æ–π —Å–ª–µ–¥
    function renderFeedback() {
        fbCtx.fillStyle = 'rgba(0, 0, 0, 0.08)'; // –∑–∞—Ç—É—Ö–∞–Ω–∏–µ
        fbCtx.fillRect(0, 0, fbCanvas.width, fbCanvas.height);
        
        // displacement —ç—Ñ—Ñ–µ–∫—Ç
        const imageData = fbCtx.getImageData(0, 0, fbCanvas.width, fbCanvas.height);
        const displaced = fbCtx.createImageData(fbCanvas.width, fbCanvas.height);
        
        for (let y = 0; y < fbCanvas.height; y++) {
            for (let x = 0; x < fbCanvas.width; x++) {
                const dx = Math.sin(y * 0.01 + performance.now() * 0.001) * audioEnergy * 3;
                const dy = Math.cos(x * 0.01 + performance.now() * 0.001) * audioEnergy * 3;
                const sx = Math.floor(x + dx);
                const sy = Math.floor(y + dy);
                
                if (sx >= 0 && sx < fbCanvas.width && sy >= 0 && sy < fbCanvas.height) {
                    const si = (sy * fbCanvas.width + sx) * 4;
                    const di = (y * fbCanvas.width + x) * 4;
                    displaced.data[di] = imageData.data[si];
                    displaced.data[di + 1] = imageData.data[si + 1];
                    displaced.data[di + 2] = imageData.data[si + 2];
                    displaced.data[di + 3] = imageData.data[si + 3];
                }
            }
        }
        fbCtx.putImageData(displaced, 0, 0);
        
        // ship trail particles
        shipTrail.push({x: shipX, y: shipY, life: 1});
        
        fbCtx.globalCompositeOperation = 'lighter';
        for (let i = shipTrail.length - 1; i >= 0; i--) {
            const p = shipTrail[i];
            p.life -= 0.02;
            if (p.life <= 0) {
                shipTrail.splice(i, 1);
                continue;
            }
            
            const hue = (sectorPhase * 360 + performance.now() * 0.1) % 360;
            fbCtx.fillStyle = `hsla(${hue}, 80%, 60%, ${p.life * 0.5})`;
            fbCtx.beginPath();
            fbCtx.arc(p.x, p.y, 15 * p.life, 0, Math.PI * 2);
            fbCtx.fill();
        }
        fbCtx.globalCompositeOperation = 'source-over';
    }

    function render(time) {
        time *= 0.001;
        const dt = Math.min(time - lastTime, 0.1);
        lastTime = time;
        
        shipX += (targetX - shipX) * 0.15;
        shipY += (targetY - shipY) * 0.15;
        
        audioEnergy *= 0.95; // –∑–∞—Ç—É—Ö–∞–Ω–∏–µ
        
        gl.viewport(0, 0, width, height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(resolutionLoc, width, height);
        gl.uniform1f(timeLoc, time);
        gl.uniform2f(shipLoc, shipX, height - shipY);
        gl.uniform1f(speedLoc, speed);
        gl.uniform1f(sectorPhaseLoc, sectorPhase);
        gl.uniform1f(audioEnergyLoc, audioEnergy);

        spawnTimer += dt;
        if (spawnTimer > spawnInterval / speed) {
            spawnEntity();
            spawnTimer = 0;
        }

        for (let i = entities.length - 1; i >= 0; i--) {
            const e = entities[i];
            e.update(dt);

            if (!e.collected && e.checkCollision(shipX, shipY)) {
                e.collected = true;
                
                if (e.type === 'alien') {
                    aliens++;
                    xdust += 50;
                    showMessage('üëΩ +50 $XDUST!');
                    audioEnergy = 1.5;
                    playAlien();
                    if (tg) tg.HapticFeedback?.notificationOccurred('success');
                } else if (e.type === 'dust') {
                    xdust += 10;
                    audioEnergy = 0.5;
                    playDust();
                    if (tg) tg.HapticFeedback?.impactOccurred('light');
                } else if (e.type === 'obstacle') {
                    xdust = Math.max(0, xdust - 20);
                    showMessage('üí• -20 $XDUST!');
                    audioEnergy = 2.0;
                    playObstacle();
                    if (tg) tg.HapticFeedback?.notificationOccurred('error');
                }
            }

            if (e.y > height + 100) entities.splice(i, 1);
        }

        if (xdust > sector * 200) {
            sector++;
            speed += 0.2;
            sectorPhase = (sector % 10) / 10;
            showMessage(`üåå SECTOR ${sector}!`, 2000);
            audioEnergy = 2.5;
            if (tg) tg.HapticFeedback?.notificationOccurred('success');
        }

        const entityData = new Float32Array(300);
        const visibleEntities = entities.filter(e => !e.collected).slice(0, 100);
        
        for (let i = 0; i < visibleEntities.length; i++) {
            const e = visibleEntities[i];
            entityData[i * 3] = e.x;
            entityData[i * 3 + 1] = height - e.y;
            entityData[i * 3 + 2] = e.typeNum;
        }
        
        gl.uniform3fv(entitiesLoc, entityData);
        gl.uniform1i(entityCountLoc, visibleEntities.length);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        renderFeedback();

        document.getElementById('xdust').textContent = `$XDUST: ${xdust}`;
        document.getElementById('level').textContent = `SECTOR: ${sector}`;
        document.getElementById('aliens').textContent = `üëΩ: ${aliens}`;
        document.getElementById('speed').textContent = speed.toFixed(1);

        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>
