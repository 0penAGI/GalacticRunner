<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic X-Dust Runner: Liquid Edition</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: var(--neon-blue);
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .hud-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #score-val { color: var(--neon-pink); font-weight: bold; font-size: 18px; }
        #sector-val { color: #ffff00; }
        #aliens-val { color: var(--neon-green); }
        
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            text-shadow: 0 0 20px var(--neon-blue);
            width: 100%;
        }
        .msg-show {
            opacity: 1 !important;
            transform: translate(-50%, -50%) scale(1.1) !important;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div class="stat-box">
                <div class="stat-row"><span>$XDUST</span> <span id="score-val">0</span></div>
                <div class="stat-row"><span>Sector</span> <span id="sector-val">1</span></div>
            </div>
            <div class="stat-box">
                <div class="stat-row"><span>Aliens</span> <span id="aliens-val">0</span></div>
                <div class="stat-row"><span>Speed</span> <span id="speed-val">1.0</span>x</div>
            </div>
        </div>
        
        <div id="message-overlay"></div>
        <div id="controls-hint">–í–µ–¥–∏ –ø–∞–ª—å—Ü–µ–º –∏–ª–∏ –º—ã—à–∫–æ–π, —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–æ—Ç–æ–∫–æ–º</div>
    </div>

<script>
    // --- Telegram WebApp Init ---
    const tg = window.Telegram?.WebApp;
    if (tg) {
        tg.ready();
        tg.expand();
        document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#000');
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { alpha: false, antialias: true });
    
    if (!gl) {
        alert('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç WebGL 2. –ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∂–∏–≤–∞—è –∫—Ä–∞—Å–∫–∞.');
        throw new Error('WebGL2 not supported');
    }

    // --- Setup & Resize ---
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        gl.viewport(0, 0, width, height);
    });

    // --- Shaders ---
    
    // 1. Vertex Shader
    const vertexShaderSource = `#version 300 es
        in vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;

    // 2. Fragment Shader (Liquid Paint Patch Applied)
    const fragmentShaderSource = `#version 300 es
        precision highp float;
        
        uniform vec2 resolution;
        uniform float time;
        uniform vec2 ship;
        uniform float speed;
        uniform float sectorPhase;
        uniform vec3 entities[100]; 
        uniform int entityCount;
        
        out vec4 fragColor;
        
        // --- BASE NOISE ---
        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        // ü©∏ PATCH 1: Add FBM and Flow
        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 5; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        vec2 flow(vec2 p, float t) {
            float n1 = fbm(p * 0.6 + t * 0.05);
            float n2 = fbm(p * 0.6 - t * 0.04);
            return vec2(n1, n2) - 0.5;
        }

        vec3 palette(float t, float phase) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.0 + phase, 0.33, 0.67 - phase);
            return a + b * cos(6.28318 * (c * t + d));
        }
        
        // --- HELPERS ---
        float circle(vec2 uv, vec2 pos, float radius) {
            return 1.0 - smoothstep(radius - 2.0, radius + 2.0, length(uv - pos));
        }
        
        float shipGlow(vec2 uv, vec2 pos) {
            float dist = length(uv - pos);
            return 0.8 * exp(-dist * 0.05) + 0.2 * exp(-dist * 0.01);
        }
        
        void main() {
            vec2 uv = gl_FragCoord.xy;
            vec2 shipPos = ship;
            
            // === BACKGROUND (LIQUID PAINT) ===
            
            // ü©∏ PATCH 2: Distort UV as liquid
            vec2 scrollUv = uv / resolution;
            vec2 flowUv = scrollUv * 2.5;
            vec2 f = flow(flowUv, time * speed);
            scrollUv += f * 0.15;

            // Tunnel effect
            vec2 toShip = scrollUv - shipPos / resolution;
            float distToShip = length(toShip);
            float tunnel = 1.0 - exp(-distToShip * 2.0);
            
            // ü©∏ PATCH 3: Dust -> Viscous Pigment
            float dust = fbm(scrollUv * 4.0 + time * speed * 0.3);
            dust = smoothstep(0.35, 0.75, dust);
            
            // ü©∏ PATCH 4: Fog -> Oil Clouds
            vec2 nebulaUv = scrollUv * 1.5;
            nebulaUv += flow(nebulaUv, time * 0.3) * 0.4;
            float nebula = fbm(nebulaUv * 2.0);
            
            // ü©∏ PATCH 5: Color becomes alive
            float pattern = mix(dust, nebula, 0.5);
            pattern = pow(pattern, 1.2);
            pattern *= tunnel;

            vec3 col = palette(pattern + time * 0.05, sectorPhase);
            col += vec3(0.1, 0.05, 0.15) * pattern;
            
            // Stars
            float stars = 0.0;
            vec2 starUv = floor(scrollUv * 150.0);
            if(hash(starUv) > 0.985) {
                float twinkle = 0.5 + 0.5 * sin(time * 5.0 + hash(starUv) * 100.0);
                stars = twinkle * hash(starUv);
            }
            col += vec3(stars) * 0.5;
            
            // Vignette
            col *= 1.0 - distToShip * 0.5;
            
            // === GAME ENTITIES ===
            for(int i = 0; i < entityCount && i < 100; i++) {
                vec3 entity = entities[i];
                vec2 entityPos = entity.xy;
                float entityType = entity.z;
                
                float c = circle(uv, entityPos, 20.0);
                
                if(c > 0.0) {
                    if(entityType < 0.5) {
                        // Dust - Golden sparkle
                        vec3 dustCol = vec3(1.0, 0.9, 0.4);
                        float sparkle = 0.7 + 0.3 * sin(time * 15.0 + float(i));
                        col = mix(col, dustCol, c * sparkle);
                    } else if(entityType < 1.5) {
                        // Alien - Bio-glow
                        vec3 alienCol = vec3(0.2, 1.0, 0.6);
                        float pulse = 0.6 + 0.4 * sin(time * 8.0 + float(i));
                        col = mix(col, alienCol, c * pulse);
                    } else {
                        // Obstacle - Hot warning
                        vec3 obstacleCol = vec3(1.0, 0.1, 0.1);
                        float danger = 0.7 + 0.3 * sin(time * 20.0);
                        col = mix(col, obstacleCol, c * danger);
                    }
                }
            }
            
            // === PLAYER SHIP ===
            float shipEffect = shipGlow(uv, shipPos);
            vec3 shipCol = vec3(0.0, 1.0, 1.0);
            
            // Ship core
            float shipCore = circle(uv, shipPos, 15.0);
            col = mix(col, shipCol, shipCore);
            
            // Ship glow
            col += shipCol * shipEffect * 0.4;
            
            // Ship trail
            vec2 trailDir = vec2(0.0, 1.0);
            for(int i = 0; i < 6; i++) {
                float offset = float(i) * 12.0;
                vec2 trailPos = shipPos + trailDir * offset + vec2(sin(time*10.0 + float(i))*2.0, 0.0);
                float trailCircle = circle(uv, trailPos, 10.0 - float(i) * 1.5);
                float fade = 1.0 - float(i) / 6.0;
                col += shipCol * trailCircle * fade * 0.6;
            }
            
            fragColor = vec4(col, 1.0);
        }
    `;

    // --- WebGL Setup ---
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader Compile Error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program Link Error:', gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // Buffer setup
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const resolutionLoc = gl.getUniformLocation(program, 'resolution');
    const timeLoc = gl.getUniformLocation(program, 'time');
    const shipLoc = gl.getUniformLocation(program, 'ship');
    const speedLoc = gl.getUniformLocation(program, 'speed');
    const sectorPhaseLoc = gl.getUniformLocation(program, 'sectorPhase');
    const entitiesLoc = gl.getUniformLocation(program, 'entities');
    const entityCountLoc = gl.getUniformLocation(program, 'entityCount');

    // --- Game State ---
    let shipX = width / 2;
    let shipY = height * 0.8;
    let targetX = shipX;
    let targetY = shipY;
    let xdust = 0;
    let aliens = 0;
    let sector = 1;
    let speed = 1.0;
    let sectorPhase = 0.0;
    
    const entities = [];
    
    class Entity {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.typeNum = type === 'dust' ? 0 : type === 'alien' ? 1 : 2;
            this.collected = false;
        }
        
        update(dt) {
            this.y += speed * 250 * dt;
        }
        
        checkCollision(sx, sy) {
            const dx = this.x - sx;
            const dy = this.y - sy;
            return Math.sqrt(dx * dx + dy * dy) < 30;
        }
    }

    // --- Spawning Logic ---
    function spawnEntity() {
        const x = Math.random() * width;
        const y = -50;
        const rand = Math.random();
        let type;
        
        if (rand < 0.25) type = 'alien';
        else if (rand < 0.70) type = 'dust';
        else type = 'obstacle';
        
        entities.push(new Entity(x, y, type));
    }

    function showMessage(text, duration = 1000) {
        const msg = document.getElementById('message-overlay');
        msg.textContent = text;
        msg.classList.add('msg-show');
        
        if (msg.timeout) clearTimeout(msg.timeout);
        
        msg.timeout = setTimeout(() => {
            msg.classList.remove('msg-show');
        }, duration);
    }

    // --- Input Handling ---
    function handleMove(x, y) {
        targetX = Math.max(20, Math.min(width - 20, x));
        targetY = Math.max(20, Math.min(height - 20, y));
    }

    // CRITICAL FIX: –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–æ–±—ã—Ç–∏—è mousedown –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–≤–∏–∂–µ–Ω–∏—è
    canvas.addEventListener('mousedown', (e) => {
        handleMove(e.clientX, e.clientY);
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (e.buttons === 1) { // –¢–æ–ª—å–∫–æ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ –º—ã—à–∏
            handleMove(e.clientX, e.clientY);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    // --- Main Loop ---
    let lastTime = 0;
    let spawnTimer = 0;
    const spawnInterval = 0.6;

    function render(timeMs) {
        timeMs *= 0.001;
        const dt = Math.min(timeMs - lastTime, 0.1);
        lastTime = timeMs;
        
        // Smooth Ship Movement
        shipX += (targetX - shipX) * 0.1;
        shipY += (targetY - shipY) * 0.1;
        
        gl.viewport(0, 0, width, height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Update Uniforms
        gl.uniform2f(resolutionLoc, width, height);
        gl.uniform1f(timeLoc, timeMs);
        gl.uniform2f(shipLoc, shipX, height - shipY);
        gl.uniform1f(speedLoc, speed);
        gl.uniform1f(sectorPhaseLoc, sectorPhase);

        // Game Logic
        spawnTimer += dt;
        if (spawnTimer > spawnInterval / speed) {
            spawnEntity();
            spawnTimer = 0;
        }

        // Update Entities & Collisions
        for (let i = entities.length - 1; i >= 0; i--) {
            const e = entities[i];
            e.update(dt);

            if (!e.collected && e.checkCollision(shipX, shipY)) {
                e.collected = true;
                
                if (e.type === 'alien') {
                    aliens++;
                    xdust += 50;
                    showMessage('üëΩ +50 $XDUST');
                    if (tg) tg.HapticFeedback?.notificationOccurred('success');
                } else if (e.type === 'dust') {
                    xdust += 10;
                    if (tg) tg.HapticFeedback?.impactOccurred('light');
                } else if (e.type === 'obstacle') {
                    xdust = Math.max(0, xdust - 20);
                    showMessage('üí• -20 $XDUST');
                    if (tg) tg.HapticFeedback?.notificationOccurred('error');
                }
            }

            // FIX: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
            if (e.y > height + 100 || e.collected) {
                entities.splice(i, 1);
            }
        }

        // Level Up Logic
        if (xdust > sector * 200) {
            sector++;
            speed += 0.1;
            sectorPhase = (sector % 10) / 10.0;
            showMessage(`‚ö†Ô∏è SECTOR ${sector} ‚ö†Ô∏è`, 2000);
            if (tg) tg.HapticFeedback?.notificationOccurred('warning');
        }

        // Pass Entity Data to Shader
        const entityData = new Float32Array(300);
        const visibleEntities = entities.slice(0, 100);
        
        for (let i = 0; i < visibleEntities.length; i++) {
            const e = visibleEntities[i];
            entityData[i * 3] = e.x;
            entityData[i * 3 + 1] = height - e.y;
            entityData[i * 3 + 2] = e.typeNum;
        }
        
        gl.uniform3fv(entitiesLoc, entityData);
        gl.uniform1i(entityCountLoc, visibleEntities.length);

        // Draw
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Update UI
        document.getElementById('score-val').textContent = xdust;
        document.getElementById('sector-val').textContent = sector;
        document.getElementById('aliens-val').textContent = aliens;
        document.getElementById('speed-val').textContent = speed.toFixed(1);

        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

</script>
</body>
</html>
