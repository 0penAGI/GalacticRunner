<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic X-Dust: Liquid Pro</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --bg-dark: #050505;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        body {
            overflow: hidden;
            background: var(--bg-dark);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--neon-blue);
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .hud-panel {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: auto;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 10px rgba(0,255,255,0.1);
        }
        .stat-row { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin: 2px 0; }
        #score-val { color: var(--neon-pink); font-weight: bold; font-size: 16px; }
        
        /* ÐšÐ½Ð¾Ð¿ÐºÐ° ÐŸÐ°ÑƒÐ·Ñ‹ */
        #pause-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }
        #pause-btn:active { background: var(--neon-blue); color: #000; }

        /* ÐžÐ²ÐµÑ€Ð»ÐµÐ¸ */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(8px);
        }
        .menu-card {
            text-align: center;
            padding: 40px;
            border: 2px solid var(--neon-blue);
            border-radius: 24px;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.15);
            max-width: 90%;
        }
        .menu-card h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px var(--neon-blue);
        }
        .menu-card p {
            color: #aaa;
            margin-bottom: 30px;
        }
        .btn-main {
            background: linear-gradient(135deg, var(--neon-blue), #00aaaa);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            margin-top: 20px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            transition: transform 0.1s;
        }
        .btn-main:active { transform: scale(0.95); }

        #message-overlay {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 15px var(--neon-blue);
            white-space: nowrap;
        }
        .msg-show { animation: popMsg 1s ease-out forwards; }
        @keyframes popMsg {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div class="stat-box">
                <div class="stat-row">DUST: <span id="score-val">0</span></div>
                <div class="stat-row">SECTOR: <span id="sector-val">1</span></div>
            </div>
            <button id="pause-btn">PAUSE</button>
        </div>
        <div id="message-overlay"></div>
    </div>

    <div id="overlay">
        <div class="menu-card">
            <h1 style="color: var(--neon-blue);">PAUSED</h1>
            <p id="pause-info">System Status: STANDBY</p>
            <button class="btn-main" onclick="togglePause()">RESUME</button>
        </div>
    </div>

<audio id="ios-unlock" loop playsinline preload="auto">
  <source src="silence.mp3" type="audio/mpeg">
</audio>
<script>
    // --- Init ---
    const tg = window.Telegram?.WebApp;
    if (tg) { 
        tg.ready(); 
        tg.expand(); 
        // ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ñ†Ð²ÐµÑ‚Ð¾Ð² Ð¿Ð¾Ð´ Ñ‚ÐµÐ¼Ñƒ TG
        document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#000');
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { antialias: false });
    
    if (!gl) alert('WebGL2 not supported');

    let width, height;
    let isPaused = false;
    
    // --- Audio System (Synthesizer) ---
    let audioCtx = null;
    let audioUnlocked = false;

    function unlockIOSMedia() {
        const a = document.getElementById('ios-unlock');
        if (!a) return;
        a.volume = 0.0001;
        const p = a.play();
        if (p && p.catch) p.catch(()=>{});
    }

    function initAudio() {
        if (!audioCtx) {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            audioCtx = new Ctx();
        }
    }

    function unlockAudio() {
        if (audioUnlocked) return;
        initAudio();
        unlockIOSMedia();
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        audioUnlocked = true;
    }

    function playSynthSound(freq, type, decay, vol) {
        if (isPaused) return;
        if (!audioCtx || audioCtx.state !== 'running') return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(Math.max(20, freq * 0.1), audioCtx.currentTime + decay);

        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + decay);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        osc.stop(audioCtx.currentTime + decay);
    }

    const sounds = {
        dust: () => playSynthSound(800, 'sine', 0.15, 0.12),
        alien: () => playSynthSound(600, 'triangle', 0.4, 0.18),
        hit: () => playSynthSound(110, 'sawtooth', 0.3, 0.22),
        level: () => {
            playSynthSound(440, 'square', 0.6, 0.12);
            setTimeout(() => playSynthSound(554, 'square', 0.6, 0.12), 90);
            setTimeout(() => playSynthSound(659, 'square', 0.6, 0.12), 180);
        }
    };

    // --- Shaders ---
    const vertexSource = `#version 300 es
        in vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }`;

    // ðŸŒŠ DOMAIN WARPING SHADER
    const fragmentSource = `#version 300 es
        precision highp float;
        uniform vec2 res;
        uniform float time;
        uniform vec2 ship;
        uniform float speed;
        uniform float phase;
        uniform float viscosity;
        uniform float density;
        uniform vec3 entities[50]; // x, y, type
        uniform int entityCount;
        out vec4 fragColor;

        // Basic Hash & Noise
        float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
        
        float noise(vec2 p) {
            vec2 i = floor(p); vec2 f = fract(p);
            f = f*f*(3.0-2.0*f);
            return mix(mix(hash(i), hash(i+vec2(1,0)), f.x), 
                       mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y);
        }

        // Fractal Brownian Motion
        float fbm(vec2 p) {
            float v = 0.0, a = 0.7;
            for(int i=0; i<5; i++) { v += a * noise(p); p *= 2.1; a *= 0.5; }
            return v;
        }

        // Domain Warping for "Oil Paint" / "Liquid Marble" effect
        float pattern(vec2 p, out vec2 q, out vec2 r) {
            q = vec2(fbm(p + vec2(0.0)), fbm(p + vec2(5.2, 1.3)));
            r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2)), fbm(p + 4.0*q + vec2(8.3, 2.8)));
            return fbm(p + 4.0*r);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / res;
            
            // ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹ Ð´Ð»Ñ Ñ„Ð¾Ð½Ð°
            vec2 p = uv * 3.0;
            
            // ÐÐ½Ð¸Ð¼Ð°Ñ†Ð¸Ñ Ð¶Ð¸Ð´ÐºÐ¾ÑÑ‚Ð¸
            vec2 q, r;
            float f = pattern(p * mix(0.8, 1.6, density) + time * 0.1 * speed * mix(0.6, 1.4, viscosity), q, r);
            
            // Ð¡Ð¼ÐµÑˆÐ¸Ð²Ð°Ð½Ð¸Ðµ Ñ†Ð²ÐµÑ‚Ð¾Ð² Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¿Ð°Ñ‚Ñ‚ÐµÑ€Ð½Ð° Ð¸ÑÐºÐ°Ð¶ÐµÐ½Ð¸Ð¹
            vec3 col = mix(
                vec3(0.02, 0.04, 0.08) * (1.0 - density),
                vec3(0.12, 0.02, 0.18) * (0.5 + density),
                f
            );
            col = mix(col, vec3(0.0, 0.3, 0.4), length(q)); // q Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÐµÑ‚ Ð·Ð° ÐºÑ€ÑƒÐ¿Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ»Ð¸Ð²Ñ‹
            col = mix(col, vec3(phase, 0.1, 0.5-phase), length(r)); // r Ð·Ð° Ð´ÐµÑ‚Ð°Ð»Ð¸
            
            // Ð£ÑÐ¸Ð»ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÑÑ‚Ð° (ÑÐ²ÐµÑ‚Ð»Ñ‹Ðµ Ð¿ÑÑ‚Ð½Ð°)
            col *= (f * f * f + 0.6 * f * f + 0.5 * f);

            // --- RENDER ENTITIES ---
            for(int i=0; i<entityCount; i++) {
                float d = length(gl_FragCoord.xy - entities[i].xy);
                if(d < 30.0) {
                    float glow = smoothstep(30.0, 0.0, d);
                    float type = entities[i].z;
                    
                    if(type == 0.0) col += vec3(1.0, 0.8, 0.2) * glow; // Dust (Gold)
                    if(type == 1.0) col += vec3(0.0, 1.0, 0.6) * glow; // Alien (Green)
                    if(type == 2.0) col += vec3(1.0, 0.1, 0.1) * glow; // Obstacle (Red)
                }
            }

            // --- RENDER SHIP ---
            float shipD = length(gl_FragCoord.xy - ship);
            // Ð’Ð½ÐµÑˆÐ½ÐµÐµ ÑÐ²ÐµÑ‡ÐµÐ½Ð¸Ðµ
            col += vec3(0.0, 0.8, 1.0) * smoothstep(40.0, 0.0, shipD) * 0.7;
            // Ð¯Ð´Ñ€Ð¾ ÐºÐ¾Ñ€Ð°Ð±Ð»Ñ (Ð±ÐµÐ»Ð¾Ðµ)
            if(shipD < 12.0) col = vec3(1.0);

            fragColor = vec4(col, 1.0);
        }
    `;

    // --- WebGL Boilerplate ---
    function createShader(gl, type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src); gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s));
            return null;
        }
        return s;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertexSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragmentSource));
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }
    
    gl.useProgram(program);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    
    const posLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const locs = {
        res: gl.getUniformLocation(program, 'res'),
        time: gl.getUniformLocation(program, 'time'),
        ship: gl.getUniformLocation(program, 'ship'),
        speed: gl.getUniformLocation(program, 'speed'),
        phase: gl.getUniformLocation(program, 'phase'),
        viscosity: gl.getUniformLocation(program, 'viscosity'),
        density: gl.getUniformLocation(program, 'density'),
        ents: gl.getUniformLocation(program, 'entities'),
        entCount: gl.getUniformLocation(program, 'entityCount')
    };

    // --- Path System ---
    const pathNodes = [];
    const PATH_LEN = 32;

    function generatePath() {
        pathNodes.length = 0;
        let v = Math.random();
        let d = Math.random();
        for (let i = 0; i < PATH_LEN; i++) {
            v = Math.min(1, Math.max(0, v + (Math.random() - 0.5) * 0.3));
            d = Math.min(1, Math.max(0, d + (Math.random() - 0.5) * 0.3));
            pathNodes.push({
                viscosity: v,
                density: d
            });
        }
    }
    generatePath();

    // --- Game Logic ---
    let score = 0, sector = 1, speed = 1.0;
    let shipX = 0, shipY = 0, targetX = 0, targetY = 0;
    const entities = [];

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        gl.viewport(0, 0, width, height);
        // Ð¦ÐµÐ½Ñ‚Ñ€Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ¾Ñ€Ð°Ð±Ð»ÑŒ Ð¿Ñ€Ð¸ ÑÑ‚Ð°Ñ€Ñ‚Ðµ
        if(shipX === 0) { shipX = targetX = width/2; shipY = targetY = height * 0.8; }
    }
    window.addEventListener('resize', resize);
    resize();

    function spawn() {
        if(isPaused || entities.length > 40) return;
        // Ð¢Ð¸Ð¿Ñ‹: 0=Dust, 1=Alien, 2=Obstacle
        // Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚Ð¸: 60% Dust, 20% Alien, 20% Obstacle
        const rand = Math.random();
        let type = 0;
        if(rand > 0.6) type = (rand > 0.8) ? 1 : 2;

        entities.push({
            x: Math.random() * width,
            y: -50,
            t: type
        });
    }

    function togglePause() {
        isPaused = !isPaused;
        const overlay = document.getElementById('overlay');
        const btn = document.getElementById('pause-btn');
        
        if (isPaused) {
            overlay.style.display = 'flex';
            btn.textContent = "RESUME";
            document.getElementById('pause-info').textContent = `Score: ${score} | Sector: ${sector}`;
        } else {
            overlay.style.display = 'none';
            btn.textContent = "PAUSE";
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }
    }
    
    // ÐŸÑ€Ð¸Ð²ÑÐ·Ñ‹Ð²Ð°ÐµÐ¼ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð¿Ð°ÑƒÐ·Ñ‹
    document.getElementById('pause-btn').onclick = (e) => { 
        e.stopPropagation(); 
        togglePause(); 
    };

    function showMsg(txt) {
        const m = document.getElementById('message-overlay');
        m.textContent = txt;
        m.classList.remove('msg-show');
        void m.offsetWidth; // Trigger reflow
        m.classList.add('msg-show');
    }

    // --- Audio Unlock (Telegram / iOS safe) ---
    document.addEventListener('pointerdown', unlockAudio, { once: true });
    document.addEventListener('touchstart', unlockAudio, { once: true, passive: true });

    // Input Handling
    const move = (e) => {
        const t = e.touches ? e.touches[0] : e;
        targetX = t.clientX; 
        targetY = t.clientY;
    };
    
    window.addEventListener('mousemove', move);
    window.addEventListener('touchstart', move, {passive:false});
    window.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive:false});

    let lastT = 0;
    let spawnTimer = 0;

    function loop(t) {
        requestAnimationFrame(loop);

        // Make node available everywhere in loop
        const node = pathNodes[(sector - 1) % PATH_LEN];
        
        // --- LOGIC UPDATE (Only if not paused) ---
        if (!isPaused) {
            const dt = Math.min((t - lastT) * 0.001, 0.1);
            lastT = t;

            // Smooth ship movement affected by viscosity (thick space effect)
            const controlDrag = 0.18 * (1.0 - node.viscosity * 0.7);
            shipX += (targetX - shipX) * controlDrag;
            shipY += (targetY - shipY) * controlDrag;

            // Spawning
            spawnTimer += dt;
            if(spawnTimer > 0.6 / speed) { 
                spawn(); 
                spawnTimer = 0; 
            }

            // Entities Update
            for(let i=entities.length-1; i>=0; i--) {
                const e = entities[i];
                e.y += speed * 250 * dt;

                // Alien gravitational attraction (field curvature)
                if (e.t === 1) {
                    const dx = e.x - shipX;
                    const dy = e.y - shipY;
                    const dist = Math.max(80, Math.hypot(dx, dy));
                    const pull = 1200 * dt * (0.3 + node.density);
                    e.x -= dx / dist * pull;
                    e.y -= dy / dist * pull;
                }

                // Collision detection
                const d = Math.hypot(e.x - shipX, e.y - shipY);
                if(d < 35) {
                    if(e.t === 0) { 
                        score += 10; 
                        sounds.dust(); 
                        if(tg) tg.HapticFeedback.impactOccurred('light'); 
                    }
                    if(e.t === 1) { 
                        score += 50; 
                        showMsg("EXTRACTED +50"); 
                        sounds.alien(); 
                        if(tg) tg.HapticFeedback.notificationOccurred('success'); 
                    }
                    if(e.t === 2) { 
                        score = Math.max(0, score-30); 
                        showMsg("COLLISION -30"); 
                        sounds.hit(); 
                        if(tg) tg.HapticFeedback.notificationOccurred('error'); 
                    }
                    entities.splice(i, 1);
                    continue;
                }
                
                // Remove off-screen
                if(e.y > height + 50) entities.splice(i, 1);
            }

            // Level Up
            if(score >= sector * 300) {
                sector++;
                speed += 0.15;
                if (sector % PATH_LEN === 1) generatePath();
                sounds.level();
                showMsg(`SECTOR ${sector} REACHED`);
            }
        } else {
            // Ð’ Ð¿Ð°ÑƒÐ·Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ lastT, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¸ Ð²Ñ‹Ñ…Ð¾Ð´Ðµ Ð½Ðµ Ð±Ñ‹Ð»Ð¾ ÑÐºÐ°Ñ‡ÐºÐ° Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
            lastT = t;
        }

        // --- RENDER UPDATE (Always) ---
        gl.uniform2f(locs.res, width, height);
        gl.uniform1f(locs.time, t * 0.001); // Background continues to flow even in pause
        gl.uniform2f(locs.ship, shipX, height - shipY); // Flip Y for WebGL
        gl.uniform1f(locs.speed, speed);
        gl.uniform1f(locs.phase, (sector % 5) / 5.0);

        // Dynamic feedback: field reacts to speed
        const dynVisc = Math.min(1.0, node.viscosity + speed * 0.05);
        const dynDens = Math.min(1.0, node.density + Math.sin(t * 0.0003) * 0.15);

        gl.uniform1f(locs.viscosity, dynVisc);
        gl.uniform1f(locs.density, dynDens);

        // Flatten entities for GPU
        const entData = new Float32Array(150); // 50 * 3
        entities.forEach((e, i) => {
            if(i < 50) {
                entData[i*3] = e.x;
                entData[i*3+1] = height - e.y; // Flip Y
                entData[i*3+2] = e.t;
            }
        });
        gl.uniform3fv(locs.ents, entData);
        gl.uniform1i(locs.entCount, Math.min(entities.length, 50));

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // UI Update
        document.getElementById('score-val').textContent = score;
        document.getElementById('sector-val').textContent = sector;
    }

    requestAnimationFrame(loop);
</script>
</body>
</html>
