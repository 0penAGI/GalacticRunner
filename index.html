<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic X-Dust Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0ff;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            pointer-events: none;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
        }
        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 16px;
        }
        #xdust {
            color: #f0f;
            font-size: 20px;
            font-weight: bold;
        }
        #level {
            color: #ff0;
        }
        #aliens {
            color: #0f0;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-shadow: 0 0 20px #0ff;
            z-index: 20;
        }
        .show {
            opacity: 1 !important;
        }
        #user-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            text-shadow: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="hud">
        <div class="hud-row">
            <div id="xdust">$XDUST: 0</div>
            <div id="level">SECTOR: 1</div>
        </div>
        <div class="hud-row">
            <div id="aliens">ðŸ‘½: 0</div>
            <div>SPEED: <span id="speed">1.0</span>x</div>
        </div>
    </div>
    <div id="message"></div>
    <div id="user-info"></div>

<script>
    // Telegram WebApp initialization
    const tg = window.Telegram?.WebApp;
    if (tg) {
        tg.ready();
        tg.expand();
        
        const user = tg.initDataUnsafe?.user;
        if (user) {
            document.getElementById('user-info').textContent = 
                `Player: ${user.first_name || 'Unknown'} (ID: ${user.id})`;
        }
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');
    
    if (!gl) {
        alert('WebGL2 not supported');
    }

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        gl.viewport(0, 0, width, height);
    });

    // Vertex shader for full-screen quad
    const vertexShaderSource = `#version 300 es
        in vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;

    // Fragment shader - ALL game rendering
    const fragmentShaderSource = `#version 300 es
        precision highp float;
        
        uniform vec2 resolution;
        uniform float time;
        uniform vec2 ship;
        uniform float speed;
        uniform float sectorPhase;
        uniform vec3 entities[100]; // x, y, type (0=dust, 1=alien, 2=obstacle)
        uniform int entityCount;
        
        out vec4 fragColor;
        
        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }
        
        vec3 palette(float t, float phase) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.0 + phase, 0.33, 0.67 - phase);
            return a + b * cos(6.28318 * (c * t + d));
        }
        
        // Draw circle (for entities)
        float circle(vec2 uv, vec2 pos, float radius) {
            return 1.0 - smoothstep(radius - 2.0, radius + 2.0, length(uv - pos));
        }
        
        // Draw ship glow
        float shipGlow(vec2 uv, vec2 pos) {
            float dist = length(uv - pos);
            return 0.8 * exp(-dist * 0.05) + 0.2 * exp(-dist * 0.01);
        }
        
        void main() {
            vec2 uv = gl_FragCoord.xy;
            vec2 shipPos = ship;
            
            // === BACKGROUND SPACE ===
            vec2 scrollUv = uv / resolution;
            scrollUv.y += time * speed * 0.3;
            
            // Multi-layer $XDUST particles
            float dust = 0.0;
            for(int i = 0; i < 4; i++) {
                float layer = float(i) + 1.0;
                vec2 p = scrollUv * layer * 3.0;
                p.y += time * speed * layer * 0.5;
                
                float n = noise(p);
                n = smoothstep(0.45, 0.55, n);
                dust += n * (1.0 / layer);
            }
            
            // Tunnel effect
            vec2 toShip = scrollUv - shipPos / resolution;
            float distToShip = length(toShip);
            float tunnel = 1.0 - exp(-distToShip * 2.0);
            
            // Nebula clouds
            vec2 nebulaUv = scrollUv * 2.0;
            nebulaUv.y += time * speed * 0.1;
            float nebula = 0.0;
            for(int i = 0; i < 3; i++) {
                nebula += noise(nebulaUv * float(i + 1) * 0.5) / float(i + 2);
            }
            
            float pattern = dust * 0.7 + nebula * 0.3;
            pattern *= tunnel;
            
            vec3 col = palette(pattern + time * 0.1, sectorPhase);
            
            // Stars
            float stars = 0.0;
            vec2 starUv = floor(scrollUv * 100.0);
            if(hash(starUv) > 0.97) {
                float twinkle = 0.5 + 0.5 * sin(time * 3.0 + hash(starUv) * 100.0);
                stars = twinkle;
            }
            col += vec3(stars) * 0.8;
            
            // Vignette
            float vignette = 1.0 - distToShip * 0.3;
            col *= vignette;
            
            // === ENTITIES ===
            for(int i = 0; i < entityCount && i < 100; i++) {
                vec3 entity = entities[i];
                vec2 entityPos = entity.xy;
                float entityType = entity.z;
                
                float c = circle(uv, entityPos, 20.0);
                
                if(c > 0.0) {
                    if(entityType < 0.5) {
                        // Dust - sparkle effect
                        vec3 dustCol = vec3(1.0, 1.0, 0.5);
                        float sparkle = 0.5 + 0.5 * sin(time * 10.0 + float(i));
                        col = mix(col, dustCol, c * sparkle);
                    } else if(entityType < 1.5) {
                        // Alien - green glow
                        vec3 alienCol = vec3(0.0, 1.0, 0.5);
                        float pulse = 0.7 + 0.3 * sin(time * 5.0 + float(i));
                        col = mix(col, alienCol, c * pulse);
                    } else {
                        // Obstacle - red warning
                        vec3 obstacleCol = vec3(1.0, 0.2, 0.0);
                        float danger = 0.6 + 0.4 * sin(time * 8.0);
                        col = mix(col, obstacleCol, c * danger);
                    }
                }
            }
            
            // === SHIP ===
            float shipEffect = shipGlow(uv, shipPos);
            vec3 shipCol = vec3(0.0, 1.0, 1.0);
            
            // Ship core
            float shipCore = circle(uv, shipPos, 15.0);
            col = mix(col, shipCol, shipCore);
            
            // Ship glow
            col += shipCol * shipEffect * 0.3;
            
            // Ship trail
            vec2 trailDir = vec2(0.0, 1.0);
            for(int i = 0; i < 5; i++) {
                float offset = float(i) * 10.0;
                vec2 trailPos = shipPos + trailDir * offset;
                float trailCircle = circle(uv, trailPos, 8.0 - float(i) * 1.5);
                float fade = 1.0 - float(i) / 5.0;
                col += shipCol * trailCircle * fade * 0.5;
            }
            
            fragColor = vec4(col, 1.0);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    const resolutionLoc = gl.getUniformLocation(program, 'resolution');
    const timeLoc = gl.getUniformLocation(program, 'time');
    const shipLoc = gl.getUniformLocation(program, 'ship');
    const speedLoc = gl.getUniformLocation(program, 'speed');
    const sectorPhaseLoc = gl.getUniformLocation(program, 'sectorPhase');
    const entitiesLoc = gl.getUniformLocation(program, 'entities');
    const entityCountLoc = gl.getUniformLocation(program, 'entityCount');

    // Game state
    let shipX = width / 2;
    let shipY = height * 0.75;
    let xdust = 0;
    let aliens = 0;
    let sector = 1;
    let speed = 1.0;
    let sectorPhase = 0;

    const entities = [];
    
    class Entity {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.typeNum = type === 'dust' ? 0 : type === 'alien' ? 1 : 2;
            this.collected = false;
        }
        
        update(dt) {
            this.y += speed * 300 * dt;
        }
        
        checkCollision(sx, sy) {
            const dx = this.x - sx;
            const dy = this.y - sy;
            return Math.sqrt(dx * dx + dy * dy) < 35;
        }
    }

    function spawnEntity() {
        const x = Math.random() * width;
        const y = -50;
        const rand = Math.random();
        let type;
        
        if (rand < 0.3) type = 'alien';
        else if (rand < 0.65) type = 'dust';
        else type = 'obstacle';
        
        entities.push(new Entity(x, y, type));
    }

    function showMessage(text, duration = 1000) {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), duration);
    }

    let spawnTimer = 0;
    const spawnInterval = 0.7;

    let targetX = shipX;
    let targetY = shipY;

    function handleMove(x, y) {
        targetX = x;
        targetY = y;
    }

    canvas.addEventListener('mousemove', (e) => {
        handleMove(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
    });

    let lastTime = 0;

    function render(time) {
        time *= 0.001;
        const dt = Math.min(time - lastTime, 0.1);
        lastTime = time;
        
        shipX += (targetX - shipX) * 0.15;
        shipY += (targetY - shipY) * 0.15;
        
        gl.viewport(0, 0, width, height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(resolutionLoc, width, height);
        gl.uniform1f(timeLoc, time);
        gl.uniform2f(shipLoc, shipX, height - shipY);
        gl.uniform1f(speedLoc, speed);
        gl.uniform1f(sectorPhaseLoc, sectorPhase);

        spawnTimer += dt;
        if (spawnTimer > spawnInterval / speed) {
            spawnEntity();
            spawnTimer = 0;
        }

        for (let i = entities.length - 1; i >= 0; i--) {
            const e = entities[i];
            e.update(dt);

            if (!e.collected && e.checkCollision(shipX, shipY)) {
                e.collected = true;
                
                if (e.type === 'alien') {
                    aliens++;
                    xdust += 50;
                    showMessage('ðŸ‘½ +50 $XDUST!');
                    if (tg) tg.HapticFeedback?.notificationOccurred('success');
                } else if (e.type === 'dust') {
                    xdust += 10;
                    if (tg) tg.HapticFeedback?.impactOccurred('light');
                } else if (e.type === 'obstacle') {
                    xdust = Math.max(0, xdust - 20);
                    showMessage('ðŸ’¥ -20 $XDUST!');
                    if (tg) tg.HapticFeedback?.notificationOccurred('error');
                }
            }

            if (e.y > height + 100) {
                entities.splice(i, 1);
            }
        }

        if (xdust > sector * 200) {
            sector++;
            speed += 0.2;
            sectorPhase = (sector % 10) / 10;
            showMessage(`ðŸŒŒ SECTOR ${sector}!`, 2000);
            if (tg) tg.HapticFeedback?.notificationOccurred('success');
        }

        // Pass entities to shader
        const entityData = new Float32Array(300);
        const visibleEntities = entities.filter(e => !e.collected).slice(0, 100);
        
        for (let i = 0; i < visibleEntities.length; i++) {
            const e = visibleEntities[i];
            entityData[i * 3] = e.x;
            entityData[i * 3 + 1] = height - e.y;
            entityData[i * 3 + 2] = e.typeNum;
        }
        
        gl.uniform3fv(entitiesLoc, entityData);
        gl.uniform1i(entityCountLoc, visibleEntities.length);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        document.getElementById('xdust').textContent = `$XDUST: ${xdust}`;
        document.getElementById('level').textContent = `SECTOR: ${sector}`;
        document.getElementById('aliens').textContent = `ðŸ‘½: ${aliens}`;
        document.getElementById('speed').textContent = speed.toFixed(1);

        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>

</body>
</html>
