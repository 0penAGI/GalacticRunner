<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic X-Dust: Audio-Reactive Evolution</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root { 
            --neon-blue: #00ffff; 
            --neon-pink: #ff00ff; 
            --bg-dark: #050505; 
        }
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body { 
            overflow: hidden; 
            background: var(--bg-dark); 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            color: var(--neon-blue); 
            touch-action: none; 
        }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud { 
            position: absolute; top: 15px; left: 15px; right: 15px; 
            display: flex; justify-content: space-between; pointer-events: auto; 
        }
        .stat-box { 
            background: rgba(0,0,0,0.6); border: 1px solid rgba(0,255,255,0.2); 
            padding: 10px 15px; border-radius: 12px; backdrop-filter: blur(8px); 
            box-shadow: 0 0 15px rgba(0,255,255,0.1);
        }
        .stat-row { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin: 2px 0; }
        #score { color: var(--neon-pink); font-weight: bold; font-size: 18px; }
        #sector { color: #ffff00; }
        
        /* Анимация спектра */
        #audio-indicator {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; gap: 4px; height: 20px; align-items: flex-end;
        }
        .bar { width: 4px; background: var(--neon-blue); height: 2px; transition: height 0.05s; }

        /* START OVERLAY */
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; pointer-events: auto; backdrop-filter: blur(10px);
        }
        .card { text-align: center; padding: 40px; border: 2px solid var(--neon-blue); border-radius: 24px; background: #000; }
        h1 { margin-bottom: 10px; text-shadow: 0 0 20px var(--neon-blue); }
        p { color: #888; margin-bottom: 30px; }
        .btn { 
            background: linear-gradient(135deg, var(--neon-blue), #008888); 
            color: #000; border: none; padding: 15px 50px; font-size: 20px; 
            font-weight: bold; border-radius: 50px; cursor: pointer; 
            box-shadow: 0 0 30px rgba(0,255,255,0.4); transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }

        #msg { 
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 32px; font-weight: bold; text-align: center; opacity: 0; 
            pointer-events: none; text-shadow: 0 0 15px var(--neon-blue); 
            white-space: nowrap;
        }
        .msg-anim { animation: pop 2s ease-out forwards; }
        @keyframes pop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.0); }
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui">
    <div class="hud">
        <div class="stat-box">
            <div class="stat-row">DUST: <span id="score">0</span></div>
            <div class="stat-row">SECTOR: <span id="sector">1</span></div>
        </div>
        <div style="font-size: 12px; text-align: right; color: #666;">
            AUDIO SYNC<br>EVOLUTION
        </div>
    </div>
    <div id="msg"></div>
    <div id="audio-indicator">
        <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
    </div>
</div>

<div id="overlay">
    <div class="card">
        <h1>X-DUST EVOLUTION</h1>
        <p>Собирай пыль, чтобы усложнить музыку.<br>Мир пульсирует в такт биту.</p>
        <button class="btn" onclick="startGame()">START ENGINE</button>
    </div>
</div>

<script>
    const tg = window.Telegram?.WebApp;
    if (tg) { tg.ready(); tg.expand(); }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { antialias: false });

    let width, height;
    let isStarted = false;
    let score = 0, sector = 1;
    
    // --- GAME STATE ---
    let shipX = 0, shipY = 0, targetX = 0, targetY = 0;
    const entities = []; // {x, y, type: 0=dust, 1=alien}
    
    // --- AUDIO ENGINE ---
    let audioCtx, analyser, dataArray;
    let nextNoteTime = 0.0;
    let beatStep = 0;
    const lookahead = 25.0; // ms
    const scheduleAheadTime = 0.1; // s
    const tempo = 240.0; // BPM (16th notes)
    const secondsPerBeat = 60.0 / tempo;
    let bassLevel = 0; // Smoothed for visual
    let trebleLevel = 0;

    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256; // 128 bins
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        // Важно: анализатор подключаем к выходу, чтобы слышать звук и видеть его
        analyser.connect(audioCtx.destination);
        
        nextNoteTime = audioCtx.currentTime;
        scheduler();
    }

    function playTone(freq, type, duration, vol, detune = 0, time = 0) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        osc.detune.value = detune;
        
        gain.gain.setValueAtTime(vol, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        
        osc.connect(gain);
        gain.connect(analyser); // <-- Connect to analyser for reactivity
        
        osc.start(time);
        osc.stop(time + duration);
    }

    function scheduler() {
        // While there are notes that will need to play before the next interval, 
        // schedule them and advance the pointer.
        while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
            scheduleNote(beatStep, nextNoteTime);
            nextNoteTime += secondsPerBeat;
            beatStep = (beatStep + 1) % 16; // 16 steps in a loop (4 bars of 4/4)
        }
        if(isStarted) setTimeout(scheduler, lookahead);
    }

    function scheduleNote(step, time) {
        // 1. KICK (Основной ритм) - Каждые 4 шага (четвертные ноты)
        if (step % 4 === 0) {
            // Pitch drop для реалистичности бочки
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1.0, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
            osc.connect(gain); gain.connect(analyser);
            osc.start(time); osc.stop(time + 0.5);
        }

        // 2. HI-HAT (Перкуссия) - Сектор 2+
        if (sector >= 2 && step % 2 !== 0) { // Восьмые ноты
            playTone(800 + Math.random()*200, 'square', 0.05, 0.1, 0, time);
        }

        // 3. BASS LINE (Мелодия) - Сектор 3+
        if (sector >= 3 && step % 2 === 0) {
            // Простая techno bassline
            const notes = [55, 55, 65, 49]; // A1, G#1...
            const note = notes[(step / 2) % 4] * (1 + sector*0.05);
            playTone(note, 'sawtooth', 0.2, 0.15, 5, time);
        }

        // 4. LEAD / ATMOSPHERE - Сектор 4+
        if (sector >= 4 && step === 0) {
            playTone(440 * (sector % 2 === 0 ? 1.5 : 1.0), 'triangle', 2.0, 0.05, 0, time);
        }
    }

    function updateAudioData() {
        if(!audioCtx) return;
        analyser.getByteFrequencyData(dataArray);
        
        // Bass: низкие частоты (первые ~10 бинов)
        let sumBass = 0;
        for(let i=0; i<10; i++) sumBass += dataArray[i];
        const rawBass = (sumBass / 10) / 255.0;
        bassLevel += (rawBass - bassLevel) * 0.2; // Smooth lerp

        // Treble: высокие частоты (~бины 50-80)
        let sumTreble = 0;
        for(let i=50; i<80; i++) sumTreble += dataArray[i];
        const rawTreble = (sumTreble / 30) / 255.0;
        trebleLevel += (rawTreble - trebleLevel) * 0.2;

        // UI Visualizer Update
        const bars = document.querySelectorAll('.bar');
        bars.forEach((b, i) => {
            // Use different frequency ranges for different bars
            const val = dataArray[i * 8] / 3;
            b.style.height = Math.max(2, val) + 'px';
        });
    }

    // --- SHADERS (LIQUID + AUDIO REACTIVE) ---
    const vertexSrc = `#version 300 es
        in vec2 pos; void main() { gl_Position = vec4(pos, 0.0, 1.0); }`;

    const fragmentSrc = `#version 300 es
        precision highp float;
        uniform vec2 res;
        uniform float time;
        uniform vec2 ship;
        uniform float bass;
        uniform float treble;
        uniform float phase;
        uniform vec3 ents[50];
        uniform int entCount;
        out vec4 fCol;

        float hash(vec2 p) { return fract(sin(dot(p, vec2(12.7, 78.3))) * 43758.5); }
        float noise(vec2 p) {
            vec2 i = floor(p), f = fract(p); f = f*f*(3.-2.*f);
            return mix(mix(hash(i), hash(i+vec2(1,0)), f.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y);
        }

        float fbm(vec2 p) {
            float v = 0.0, a = 0.5;
            for(int i=0; i<5; i++) { v += a * noise(p); p *= 2.1; a *= 0.5; }
            return v;
        }

        // Domain Warping с аудио-инъекцией
        float pattern(vec2 p, out vec2 q, out vec2 r) {
            // Audio Injection: Bass масштабирует координаты (Pump эффект)
            vec2 scale = vec2(1.0) + bass * 0.3;
            
            q = vec2(fbm(p * scale + vec2(0.0)), fbm(p * scale + vec2(5.2, 1.3)));
            
            // Audio Injection: Treble добавляет хаотичность в средний слой
            r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2)), fbm(p + 4.0*q + vec2(8.3, 2.8)));
            
            // Audio Injection: Bass влияет на глубину искажения
            float shift = bass * 0.5;
            return fbm(p + 4.0*r + shift);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / res;
            vec2 p = uv * 3.0;
            
            vec2 q, r;
            // Время замедляется или ускоряется в зависимости от баса
            float t_mod = time * (1.0 + bass * 0.2);
            float f = pattern(p + t_mod * 0.1, q, r);
            
            vec3 col = mix(vec3(0.0, 0.05, 0.1), vec3(0.1, 0.0, 0.2), f);
            col = mix(col, vec3(0.0, 0.3, 0.4), length(q));
            
            // Treble меняет цвет (вспышки)
            vec3 highCol = vec3(0.8, 0.4, 1.0);
            col = mix(col, highCol, length(r) * treble * 2.0);
            
            // Пост-обработка
            col *= (f * f * f + 0.6 * f * f + 0.5 * f);

            // Ship Glow reacts to beat too
            float dShip = length(gl_FragCoord.xy - ship);
            float beatGlow = smoothstep(50.0, 0.0, dShip) * (1.0 + bass * 0.5);
            col += vec3(0.0, 0.8, 1.0) * beatGlow;
            if(dShip < 12.0) col = vec3(1.0);

            // Entities
            for(int i=0; i<entCount; i++) {
                float d = length(gl_FragCoord.xy - ents[i].xy);
                if(d < 25.0) {
                    float glow = smoothstep(25.0, 0.0, d);
                    if(ents[i].z < 0.5) col += vec3(1.0, 0.8, 0.2) * glow; // Dust
                    else col += vec3(0.0, 1.0, 0.5) * glow * (1.0 + treble); // Alien
                }
            }

            fCol = vec4(col, 1.0);
        }
    `;

    // --- WEBGL SETUP ---
    const prg = gl.createProgram();
    function compile(t, s) { 
        const sh = gl.createShader(t); gl.shaderSource(sh, s); gl.compileShader(sh); 
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(sh));
        gl.attachShader(prg, sh); 
    }
    compile(gl.VERTEX_SHADER, vertexSrc);
    compile(gl.FRAGMENT_SHADER, fragmentSrc);
    gl.linkProgram(prg); gl.useProgram(prg);

    const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const pLoc = gl.getAttribLocation(prg, 'pos');
    gl.enableVertexAttribArray(pLoc); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);

    const loc = {
        res: gl.getUniformLocation(prg, 'res'),
        time: gl.getUniformLocation(prg, 'time'),
        ship: gl.getUniformLocation(prg, 'ship'),
        bass: gl.getUniformLocation(prg, 'bass'),
        treble: gl.getUniformLocation(prg, 'treble'),
        phase: gl.getUniformLocation(prg, 'phase'),
        ents: gl.getUniformLocation(prg, 'ents'),
        entCount: gl.getUniformLocation(prg, 'entCount')
    };

    // --- GAME LOGIC ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        gl.viewport(0, 0, width, height);
        if(shipX === 0) { shipX = targetX = width/2; shipY = targetY = height * 0.8; }
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        isStarted = true;
        initAudio();
        if(tg) tg.HapticFeedback.impactOccurred('medium');
    }

    window.addEventListener('touchmove', e => {
        e.preventDefault();
        targetX = e.touches[0].clientX;
        targetY = e.touches[0].clientY;
    }, {passive: false});

    window.addEventListener('mousemove', e => {
        targetX = e.clientX;
        targetY = e.clientY;
    });

    let lastTime = 0;
    let spawnTimer = 0;

    function loop(t) {
        requestAnimationFrame(loop);
        if(!isStarted) return;

        const dt = Math.min((t - lastTime) * 0.001, 0.1);
        lastTime = t;

        updateAudioData();

        // Physics
        shipX += (targetX - shipX) * 0.1;
        shipY += (targetY - shipY) * 0.1;

        spawnTimer += dt;
        // Чем выше сектор, тем быстрее спавн
        if(spawnTimer > 0.4 / (1 + sector*0.1)) { 
            // Type 0 = Dust, Type 1 = Alien (Evolution)
            const type = Math.random() > 0.9 ? 1 : 0; 
            entities.push({
                x: Math.random() * width, 
                y: -30, 
                t: type
            });
            spawnTimer = 0; 
        }

        for(let i=entities.length-1; i>=0; i--) {
            const e = entities[i];
            e.y += (150 + sector * 20) * dt; // Скорость растет с сектором

            const dist = Math.hypot(e.x - shipX, e.y - shipY);
            if(dist < 35) {
                if(e.t === 1) { 
                    // ALIEN / EVOLUTION
                    score += 50; 
                    if(sector < 5) sector++;
                    showMessage(`SECTOR ${sector} UPGRADE!`);
                    if(tg) tg.HapticFeedback.notificationOccurred('success');
                } else { 
                    // DUST
                    score += 10;
                    if(tg) tg.HapticFeedback.impactOccurred('light');
                }
                entities.splice(i, 1);
            } else if(e.y > height + 50) {
                entities.splice(i, 1);
            }
        }

        // Render
        gl.uniform2f(loc.res, width, height);
        gl.uniform1f(loc.time, t * 0.001);
        gl.uniform2f(loc.ship, shipX, height - shipY);
        gl.uniform1f(loc.bass, bassLevel);
        gl.uniform1f(loc.treble, trebleLevel);
        gl.uniform1f(loc.phase, sector / 5.0);

        const entData = new Float32Array(150);
        entities.slice(0, 50).forEach((e, i) => {
            entData[i*3] = e.x;
            entData[i*3+1] = height - e.y;
            entData[i*3+2] = e.t;
        });
        gl.uniform3fv(loc.ents, entData);
        gl.uniform1i(loc.entCount, Math.min(entities.length, 50));

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        document.getElementById('score').textContent = score;
        document.getElementById('sector').textContent = sector;
    }

    function showMessage(txt) {
        const m = document.getElementById('msg');
        m.textContent = txt;
        m.classList.remove('msg-anim');
        void m.offsetWidth;
        m.classList.add('msg-anim');
    }

    requestAnimationFrame(loop);
</script>
</body>
</html>
